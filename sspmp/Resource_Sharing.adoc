[[m-mode-modification]]
== "Smpmpdeleg" Extension for Sharing Hardware Resources between PMP and SPMP

Given that the PMP and SPMP registers have a similar layout of address/config registers and the same address matching logic, reusing registers and comparators between PMP and SPMP is beneficial to save hardware resources.
This chapter presents the `Smpmpdeleg` extension, a resource sharing mechanism enabling dynamic reallocation of hardware resources between PMP and SPMP.

This extension is required when implementing `Sspmp` (<<S-level_Physical_Memory_Protection>>) with M-mode (i.e., `Sm1p13`).
To remove unnecessary optionality and to simplify the specification, when `Smpmpdeleg` is implemented, 64 PMP entries are required.
An implementation can still choose how many entries are actually provided, with the rest just being read-only zero.


[[PMP_Entry_Sharing]]
=== Resource Sharing between PMP and SPMP

The `Smpmpdeleg` extension enables delegation of PMP entries for S-level use.
These delegated entries are referred to as S-level PMP (SPMP) entries.

A MXLEN-bit M-mode CSR called `mpmpdeleg` is introduced to control the sharing of PMP entries between PMP and SPMP.
The layout of `mpmpdeleg` is shown in <<mpmpdeleg_format_rv64>>:

. The `pmpnum` field is a WARL field specifying the index of the lowest PMP entry delegated to S-level. 
All PMP entries with an index greater than or equal to `pmpnum` are delegated as SPMP entries.
. If `pmpnum` is written with a value greater than the number of implemented PMP entries, the field will read back as the number of implemented PMP entries.
. When `pmpnum` is set to zero, all PMP entries are delegated; when it is set to the number of implemented PMP entries, no entries are delegated.
. Unless `pmpnum` is hardwired, its reset value equals the number of implemented PMP entries.
. If no PMP entries are delegated, the `Sspmp` extension is treated as not implemented. All SPMP related registers should not be accessible. An attempt to access them should raise an illegal instruction exception.


[[mpmpdeleg_format_rv64]]
.mpmpdeleg CSR format.
include::images/bytefield/mpmpdeleg_format_rv64.adoc[]



[NOTE]
====
The `mpmpdeleg.pmpnum` is WARL, and allows an implementation to hardwire the PMP/SPMP split if desired.
====

*Addressing:*

Both PMP and SPMP entries will be supported contiguously.
The PMP entries begin with the lowest CSR number, while the SPMP entries begin with `pmpnum`.
For instance, given an implementation with a total of 64 PMP entries, if `pmpnum` is set to 16 during runtime, then:

. `PMP entry[0..15]` would map to `PMP[0..15]`, composed by CSR pairs `pmpcfg[0..3]` for RV32 or `pmpcfg[0,2]` for RV64 and `pmpaddr[0..15]`.
. The remaining entries, `PMP entry[16..63]`, would be mapped as `SPMP[0..47]`, composed by CSR pairs `spmpcfg[0..11]` for RV32 or `spmpcfg[0,2,4,6,8,10]` for RV64 and `spmpaddr[0..47]` (see <<spmp_csrs>>).
. A read of an out-of-index entry (e.g., `PMP[16]` or `SPMP[48]`) will return 0, and a write to such an entry will be ignored.


*Re-configuration:*

. M-mode software can re-configure the allocation of entries for PMP vs. SPMP by modifying the `mpmpdeleg` CSR.
+
. The `pmpnum` must be set to a value larger than the index of any *locked* PMP entry.
For example, if `PMP[7]` is locked, `pmpnum` must be no less than 8, or the write will be ignored, and the field will read back previous value.


[[m_mode_indirect_access]]
=== The Access Methods for SPMP CSRs in M-mode
M-mode can access PMP entries directly via PMP CSRs (i.e., `pmpcfg` and `pmpaddr`).
Whereas the delegated SPMP entries are indirectly accessed via xiselect (i.e., `siselect` and `miselect`).

Each `miselect` represents an access to the corresponding SPMP CSRs (see <<spmp_csrs>>).
The `mireg` accesses `spmpaddr`, and the `mireg2` accesses `spmpcfg`.
`mireg3`, `mireg4`, `mireg5`, and `mireg6` are read-only 0.

There is no ordering guarantee between writes to different SPMP CSRs via indirect access.
Executing an `SFENCE.VMA` instruction with `rs1=x0` and `rs2=x0` orders all following implicit and explicit accesses with respect to all preceding writes to SPMP CSRs.

The `spmpcfg[i].L` bit can only be reset when accessing by the execution environment (M-mode in this case) via `miselect`.

The `miselect` has the same view of `siselect` (see <<access_method>>).
For example, given an implementation with 64 PMP entries, where 48 entries are delegated to S-level.
S-mode can access `SPMP[0..47]` via `siselect#0..47`.
M-mode can access `SPMP[0..47]` via `siselect#0..47` or `miselect#0..47`.
In such case, any attempt by both privileged modes to access `SPMP[i]`, where `i >= 48`, will return zero. 
Writes to such SPMP entries will be ignored.


[cols="^1,^2",stripes=even, options="header"]
|===
|`miselect` number| indirect CSR access of `mireg`
|`miselect#0`|`mireg` -> `spmpaddr[0]`, `mireg2` -> `spmpcfg[0]`
|`miselect#1`|`mireg` -> `spmpaddr[1]`, `mireg2` -> `spmpcfg[1]`
|    ...     |    ...     
|`miselect#63`|`mireg` -> `spmpaddr[63]`, `mireg2` -> `spmpcfg[63]`
|===

