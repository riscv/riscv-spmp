[[guidelines]]
== Recommended Programming Guidelines

Two primary models guide the configuration of SPMP for isolating user-mode tasks from each other and from the S-mode operating system (OS).
The selection of a model hinges on whether the number of available SPMP entries is sufficient to simultaneously contain all memory regions required by both user tasks and the OS.

- *Static Configuration*: This model involves programming all SPMP entries once at system initialization.
It is predicated on the availability of enough entries to statically map all memory regions for both user tasks and the OS.
This approach is only viable if the `Sspmpsw` extension is implemented.

- *Dynamic Configuration*: This model requires reprogramming SPMP entries during each context switch.
It is employed when the SPMP entry count is insufficient to concurrently map all task memory regions, necessitating dynamic updates to maintain memory isolation.


=== Static Configuration

The static configuration model is applicable when the number of SPMP entries is sufficient to map all memory regions for both user-mode tasks and the OS.
Under this model, SPMP entries are configured a single time at system initialization and are not modified at runtime.
Consequently, context switches between user-mode tasks only require updating the `sspmpswitch` register(s).

During the boot process, machine-mode software is responsible for allocating SPMP entries and configuring them with the address ranges and permissions required by supervisor-mode software.

The OS then proceeds to populate the `spmpaddr[i]` and `spmpcfg[i]` CSRs with the specific address ranges and permissions for each user-mode task.

To protect its own memory, the OS also configures a set of SPMP entries for its address space, ensuring the `spmpcfg[i].U` (User) bit is cleared for these entries.
Following initialization, the OS must activate its own entries by setting the corresponding bits in the `sspmpswitch` register.

Before dispatching the first user task, the OS activates the SPMP entries assigned to that task by setting the appropriate bits in `sspmpswitch`.
During a context switch, the OS atomically deactivates the outgoing task's entries and activates the incoming task's entries using the `CSRRC` and `CSRRS` instructions, respectively.
On RV32 systems, `sspmpswitch` and `sspmpswitchh` must be updated as an uninterruptible sequence to guarantee complete protection.


=== Dynamic Reconfiguration

The dynamic model is necessary when the number of available SPMP entries is insufficient to concurrently map all memory regions for the supervisor and all user tasks.
Consequently, the OS must dynamically reconfigure the SPMP entries assigned to user tasks at every context switch.
It is important to note that the number of SPMP entries on a hart must still be adequate to hold all supervisor entries plus the entries for one user-mode task at any given time.

The following sequence details the recommended procedure for dynamic reconfiguration:

1. *Disable Outgoing Task Entries*.
Disable the SPMP entries for the outgoing task using a bitmask of its active entries, which is typically maintained in the task's control block.
If the `Sspmpsw` extension is available, the OS clears the relevant bits in `sspmpswitch` via a `CSRRC` instruction.
Otherwise, the OS clears the `spmpcfg[i].A` field for each of the task's entries.

2. *Update SPMP Address Registers*.
Program the `spmpaddr[i]` CSRs with the memory region boundaries of the incoming task.

3. *Update SPMP Configuration Registers*.
For each relevant `spmpcfg[i]` field:

- First, clear the existing configuration bits with a `CSRRC` instruction.

- Then, set the new configuration bits with a `CSRRS` instruction.

4. *Enable Incoming Task Entries*. Activate the SPMP entries for the incoming task using its corresponding bitmask. If the `Sspmpsw` extension is implemented, the OS sets the bits in `sspmpswitch` with a `CSRRS` instruction. Otherwise, the OS sets the `spmpcfg[i].A` field for each of the new task's entries.


[NOTE]
====
SPMP entries configured to protect the supervisor, which are identified by `spmpcfg[i].U == 0`, should be treated as resident. 
It is highly recommended that these entries not be reprogrammed during the context switch procedure. 
Keeping supervisor entries persistent minimizes reconfiguration overhead and guarantees the consistent enforcement of supervisor memory protection.
====

=== Entry Configuration Recommendations

Programming SPMP entries involves a trade-off between the Naturally Aligned Power-of-Two (NAPOT) and Top-of-Range (TOR) address-matching modes (see <<address_matching>>).

While NAPOT provides a compact, single-entry encoding for power-of-two-aligned regions, it can cause internal fragmentation if the allocated region is larger than required, leading to memory inefficiency.
Conversely, TOR mode typically requires two entries to define an arbitrary region (base and top), which can consume the available entries more rapidly.
However, TOR may prove more entry-efficient for certain power-of-two aligned regions.

This trade-off is particularly pronounced in Microcontroller Unit (MCU) systems, where memories often have a sparse, fixed mapping.
In such scenarios, a rigid adherence to either NAPOT or a naive pairing of TOR entries can be inefficient or create unintended protection gaps.
Furthermore, using consecutive or overlapping TOR entries to define multiple regions with distinct permissions can introduce subtle and hazardous dependencies.
For example, sharing a spmpaddr register as a boundary between a supervisor and a user region means that shrinking the supervisor region could unintentionally enlarge the user region.
Likewise, modifying a shared boundary during a context switch might inadvertently expose protected memory.

To mitigate these risks, the following disciplined configuration model is recommended:

- Exclusively use the TOR mode, and treat each even/odd indexed pair of `spmpaddr[i]` registers as a single base/top definition for a memory region.

- Establish a convention where SPMP entries are managed in pairs, such as (0, 1), (2, 3), ..., (62, 63).
Region activation should only be controlled via the odd-indexed entries (e.g., `sspmpswitch[1]`, `sspmpswitch[3]`), as each odd entry completes a region's definition.

- Allocate SPMP entry pairs in descending order of their indices, from highest to lowest.
This strategy, which corresponds to an ascending order of priority, permits the OS to create temporary, higher-priority subregions using lower-indexed entries without disturbing existing configurations.

Adhering to this structured approach with TOR-mode entries fosters clearer isolation boundaries, minimizes the risk of configuration errors, and enhances the runtime flexibility of the memory protection scheme.


=== Reconfiguration Non-preemption and Synchronization

To maintain the integrity of the SPMP configuration, the entire reconfiguration sequence during a context switch must execute atomically as a non-preemptible critical section.
This is necessary because the process involves modifications to multiple CSRs, and any interruption could leave the system in an inconsistent or insecure state.

For the *dynamic reconfiguration model*, this critical section must encompass all updates to `spmpaddr[i]`, `spmpcfg[i]`, and `sspmpswitch`.
For the *static configuration model*, atomicity is a concern only on RV32 systems with over 32 SPMP entries, which require a coordinated update of both `sspmpswitch` and `sspmpswitchh`.

To block asynchronous interrupts during this process, the supervisor must temporarily clear the `SIE` (Supervisor Interrupt Enable) bit in the `sstatus` CSR.

By enforcing non-preemption and correct synchronization, the software guarantees that SPMP enforcement remains deterministic, secure, and verifiable across all context switches.

