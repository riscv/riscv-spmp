[[S-level_Physical_Memory_Protection]]
== "Sspmp" Extension for S-level Physical Memory Protection (SPMP)

The RISC-V S-level Physical Memory Protection (SPMP) extension provides per-hart supervisor-mode control registers to allow physical memory access privileges (read, write, execute) to be specified for each physical memory region.

Memory accesses succeed only if both PMP/ePMP and SPMP permission checks pass.
The implementation can perform SPMP checks in parallel with the PMA and PMP checks.
The SPMP exception has higher priority than PMP or PMA exceptions (i.e., if the access violates both SPMP and PMP/PMA, the SPMP exception will be reported).

SPMP checks are applicable to all memory accesses where the effective privilege mode is less than M.

SPMP can grant permissions to U-mode, which has none by default.
SPMP can also revoke permissions from S-mode.


[[spmp-and-paging]]
=== SPMP and Paging
SPMP and paged virtual memory cannot be active simultaneously for two reasons:

. An additional permission check layer would be introduced for each memory access.
+
. Sufficient protection is provided by paged virtual memory.

The table below shows which mechanism to use. (Assume both paged virtual memory and SPMP are implemented.)

[cols="^1,^1", stripes=even, options="header"]
|===
|satp|Isolation mechanism
|satp.mode == Bare|SPMP only
|satp.mode != Bare|Paged Virtual Memory only
|===


=== Extension Dependencies

. The SPMP is dependent on `Ss1p13`.
+
. The `Smpmpdeleg` extension is required when M-mode (i.e., `Sm1p13`) is implemented.
+
. The `Sscsrind` extension must be implemented to support indirect CSR access.
+
. The `sstatus.SUM` (permit Supervisor User Memory access) bit must be *writable*, which is a change from the Privileged Architecture (i.e., `Svbare`). In SPMP, this bit modifies how S-mode load and store operations access user memory, so it must be writable.
+
. The `sstatus.MXR` (Make eXecutable Readable) bit must be *writable*, which is also a change from the Privileged Architecture (i.e., `Svbare`). In SPMP, this bit is made writable to support M-mode emulation handlers where instructions are read with `MXR=1` and `MPRV=1`.


[[spmp_csrs]]
=== S-level Physical Memory Protection CSRs

SPMP entries are described by a 16-bit field in an XLEN-bit configuration register and an XLEN-bit address register. 
*The SPMP registers are only indirectly accessible from S-mode (see <<access_method>>).*
When the TOR mode is used, the address register associated with the preceding SPMP entry is also used (detailed in <<address_matching>>). Up to 64 SPMP entries are supported.


[NOTE]
====
An SPMP entry denotes a pair of `spmpcfg[i]` / `spmpaddr[i]` registers.

An SPMP rule is described by the contents of an `spmpcfg` register and its associated `spmpaddr` register(s) that together encode a valid protected physical memory region and its restrictions, where `spmpcfg[i].A != OFF`, and if `spmpcfg[i].A == TOR` then `spmpaddr[i-1] < spmpaddr[i]`.
====


The SPMP address registers are CSRs named `spmpaddr0`-`spmpaddr63`, and has the same layout as the PMP architecture.
For RV32, each SPMP address register encodes bits 33-2 of 34-bit physical address, as shown in <<spmpaddr-rv32>>.
For RV64, each SPMP address encodes bits 55-2 of a 56-bit physical address, as shown in <<spmpaddr-rv64>>.
Fewer address bits may be implemented for specific reasons, e.g., systems with smaller physical address space.
The number of address bits should be the same for all *writable SPMP entries*.
Not all physical address bits may be implemented, and so the SPMP address registers are WARL, except as otherwise permitted by granularity rules. See the {privspec}, Section 3.7: Physical Memory Protection, Address Matching.

[[spmpaddr-rv32]]
.SPMP address register format, RV32.
include::images/bytefield/spmpaddr-rv32.adoc[]

[[spmpaddr-rv64]]
.SPMP address register format, RV64.
include::images/bytefield/spmpaddr-rv64.adoc[]

Each SPMP entry features a 16-bit configuration field, denoted as `spmpcfg[i]`, whose lower 8 bits alias the 8 bits of the corresponding PMP configuration register field.
The layout within each `spmpcfg[i]` is shown in <<spmpcfg>>.
The rules and encodings for permission are explained in <<encoding>>.

. The R/W/X bits control read, write, and instruction execution permissions.

. The A field will be described in <<address_matching>>.

. Bits 5 and 6 are reserved for future standard use.

. The L bit marks an entry as locked. 
Setting the L bit locks the SPMP entry even when the A field is set to OFF. 
Writes to locked `spmpcfg[i]` and `spmpaddr[i]` will succeed only with execution environment access via `miselect`. 
Writes to locked `spmpcfg[i]` and `spmpaddr[i]` are ignored via the `siselect` CSR regardless of the privilege mode. 
Additionally, if `spmpcfg[i].A` of the locked entry is set to TOR, writes to `spmpaddr[i-1]` via `siselect` are ignored.

. An implementation can hardwire the L bit to `0` if the lock functionality is not required.

. For a rule that is not `Shared-Region`, the U bit marks it as *U-mode-only* when set and *S-mode-only* when cleared (details in <<encoding>>).

. The SHARED bit is used to mark *Shared-Region* rules.


[[spmpcfg]]
.SPMP configuration register format.
include::images/bytefield/spmpcfg.adoc[]


[NOTE]
====
The L bit can be used by M-mode to contain software running in S-mode by setting and locking highest-priority SPMP entries with `spmpcfg[i].U == 1`. This can be useful to prevent privilege escalation attacks that would reprogram SPMP entries used to limit S-mode accesses.
Although this could arguably be achieved by using PMP/ePMP entries, the resulting configuration would not be equivalent as they do not differentiate between S and U modes. Furthermore, in cases resource sharing is statically defined (i.e., `mpmpdeleg.pmpnum` is hardwired - see <<PMP_Entry_Sharing>>) there may be insufficient PMP/ePMP entries available to implement the desired isolation.
====



[[encoding]]
=== Encoding of Permissions


SPMP has three kinds of rules: *S-mode-only*, *U-mode-only* and *Shared-Region* rules.

. An *S-mode-only* rule is *enforced* on Supervisor mode and *denied* on User mode.
+
. A *U-mode-only* rule is *enforced* on User modes and is either *denied* or *enforced* on Supervisor mode depending on the value of `sstatus.SUM` bit:
+
* If `sstatus.SUM` is set, a U-mode-only rule is enforced on Supervisor mode, but denies executable permission by S-mode (denoted as *EnforceNoX* in <<spmpencode>>). This ensures the Supervisor Memory Execution Prevention (SMEP) guarantee.
+
* If `sstatus.SUM` is cleared, a U-mode-only rule is denied on Supervisor mode. This ensures the Supervisor Memory Access Prevention (SMAP) guarantee.
+
. `spmpcfg.SHARED == 1 and spmpcfg.U == 1`, denotes a *Shared-Region* rule. The SUM bit is ignored in this case.
+
. A *Shared-Region* rule is *enforced* on both Supervisor and User modes, with the restriction that read and write permissions are mutually exclusive in User mode.
+
. The R, W, and X fields form a collective WARL field.
+
. The encoding `spmpcfg.RWX=010`, `spmpcfg.RWX=011`, and the combination `spmpcfg.SHARED == 1 and spmpcfg.U == 0` is reserved for future standard use.

The encoding and results are shown in <<spmpencode>>:

[[spmpencode]]
image::SPMP_Encoding_Table_v11.svg[title="SPMP Encoding Table"]

*Deny*: Access fails.

*Enforce*: The R/W/X permissions specified in `spmpcfg` are enforced on accesses.

*EnforceNoX*: The R/W permissions specified in `spmpcfg` are enforced on accesses, while execute permission is revoked.

*Reserved*: It is reserved for future use.

*SUM bit*: The SPMP uses the `sstatus.SUM` (permit Supervisor User Memory access) bit to modify the privilege with which S-mode loads and stores access physical memory. The semantics of `sstatus.SUM` in SPMP are consistent with those of the Machine-Level ISA (please refer to the "Memory Privilege in mstatus Register" subsection in the {privspec} for detailed information).


[[address_matching]]
=== Address Matching

The A field in an SPMP entry's configuration register encodes the address-matching mode of the associated SPMP address register.
The encoding of this field is shown in the following table:

[cols="^1,^1,^3", stripes=even, options="header"]
|===
|spmpcfg[i].A|Name|Description
|0|OFF|Null region (disabled)
|1|TOR|Top of range
|2|NA4|Naturally aligned four-byte region
|3|NAPOT|Naturally aligned power-of-two region, â‰¥8 bytes
|===

It aligns with PMP/ePMP. Please refer to the "Address Matching" subsection of PMP in the {privspec} for detailed information.


[NOTE]
====
Software may determine the SPMP granularity by writing zero to `spmpcfg[i]`, then writing all ones to `spmpaddr[i]`, then reading back `spmpaddr[i]`. If asciimath:[G] is the index of the least-significant bit set, the SPMP granularity is asciimath:[2^{G+2}]

Software may also determine the size of physical address by setting `spmpcfg[i].A == 0b11`, then writing all ones to `spmpaddr[i]` and reading back. (Please refer to the "NAPOT range encoding in PMP address and configuration registers" table in the {privspec} for detailed information.)

The `spmpcfg[i].A` is WARL, so an implementation can hardwire the address matching method to a specific one it desires.
====


=== Matching Logic


* SPMP entries are statically prioritized.
+
* The lowest-numbered SPMP entry that matches any byte of an access (indicated by an address and the accessed length) determines whether that access is allowed or denied.
+
* This matching SPMP entry must match *all* bytes of the access, or the access fails and an instruction, load, or store page-fault exception is generated (see <<exceptions>>).
+
* This matching is done irrespective of the SHARED, U, R, W, and X bits.


On some implementations, misaligned loads, stores, and instruction fetches may also be decomposed into multiple accesses, some of which may succeed before an exception occurs.
In particular, a portion of a misaligned store that passes the SPMP check may become visible, even if another portion fails the SPMP check.
The same behavior may manifest for stores wider than XLEN bits (e.g., the FSD instruction in RV32D), even when the store address is naturally aligned.

1. If the effective privilege mode of the access is M, the access is `allowed`.
2. If the effective privilege mode of the access is S/U and no SPMP entry matches, but at least one SPMP entry is implemented, the access is `denied`.
3. Otherwise, each access is checked according to the permission bits in the matching SPMP entry. That access is allowed if it satisfies the permission checking with the encoding corresponding to the access type.


[NOTE]
====
The SPMP rules are checked for all implicit and explicit accesses in all S-mode and lesser-privileged modes.

The execution environment should configure SPMP entry(s) to grant the most permissive access to S-mode. S-mode software can then further refine SPMP entries as desired.
====


[[access_method]]
=== The Access Method for SPMP CSRs in S-mode
Each `siselect` represents an access to the corresponding SPMP CSRs.
The `sireg` accesses `spmpaddr`, and the `sireg2` accesses `spmpcfg`.
`sireg3`, `sireg4`, `sireg5`, and `sireg6` are read-only 0.

S-mode can set `spmpcfg[i].L` to lock an SPMP entry.
When `spmpcfg[i].L` is set, SPMP writes via `siselect` are ignored, regardless of the privilege mode.
Only execution environment access via `miselect` can reset `spmpcfg[i].L` (see <<m_mode_indirect_access>>).

// Given an implementation with 64 PMP entries, where 48 entries are delegated to S-level.
The SPMP entries start from zero. 
Given an implementation with 48 SPMP entries.
S-mode can only access `SPMP[0..47]` via `siselect#0..47`.
Otherwise, the reads of out-of-index SPMP entries will return zero, and writes will be ignored.


[cols="^1,^2",stripes=even, options="header"]
|===
|`siselect` number| indirect CSR access of `sireg`
|`siselect#0`|`sireg` -> `spmpaddr[0]`, `sireg2` -> `spmpcfg[0]`
|`siselect#1`|`sireg` -> `spmpaddr[1]`, `sireg2` -> `spmpcfg[1]`
|    ...     |    ...
|`siselect#63`|`sireg` -> `spmpaddr[63]`, `sireg2` -> `spmpcfg[63]`
|===

[NOTE]
====
The rationale for the fact that execution environment cannot reset `spmpcfg[i].L` via `siselect` is to separate this permission by the CSR address space rather than only by privileged mode.

The rationale for SPMP to only assign one entry per `siselect` value is due to a performance consideration.
If multiple SPMP entries are assigned to each `siselect`, a jump table or additional calculations would be needed to determine which `sireg` to access.

When accessing `spmpcfg1` via `siselect` and `sireg2`, all 16 bits will be written right-justified, despite the higher 8 bits and lower 8 bits not being stored in the same register array.

Please refer to the `Sscsrind` extension specification in the {privspec} for details on indirect CSR accesses.
====


[[exceptions]]
=== Exceptions
When an access fails, SPMP generates an exception based on the access type (i.e., load accesses, store/AMO accesses, and instruction fetches). Each exception has a different code.

The SPMP extension reuses page fault exception codes for SPMP faults since page faults are typically delegated to S-mode.
S-mode software (i.e., an OS) can distinguish between SPMP-generated exceptions and page faults by checking `satp.mode`, since SPMP and paged virtual memory cannot be active simultaneously (as described in <<spmp-and-paging>>).

Note that a single instruction may generate multiple accesses, which may not be mutually atomic.

Table of exception codes:

[cols="^1,^1,^1", stripes=even, options="header"]
|===
|Interrupt|Exception Code|Description
|0|12|Instruction page fault
|0|13|Load page fault
|0|15|Store/AMO page fault
|===

[NOTE]
====
Please refer to Table "Supervisor cause register (scause) values after trap" in the {privspec} for detailed information on exception codes.
====

// *Delegation*: Unlike PMP, which uses access faults for violations, SPMP uses page faults for violations. The benefit of using page faults is that the violations caused by SPMP can be delegated to S-mode, while the access violations caused by PMP may remain undelegated and thus still be handled by machine mode.
