[[S-level_Physical_Memory_Protection]]
== "Sspmp" Extension for S-level Physical Memory Protection (SPMP)

The RISC-V S-level Physical Memory Protection (SPMP) mechanism provides per-hart control registers in supervisor mode.
These registers define physical memory access privileges—read, write, and execute—for discrete physical memory regions.

A memory access is successful only when permission checks for both PMP/ePMP and SPMP pass.
SPMP checks can be performed by the hardware in parallel with PMA and PMP checks.
SPMP exceptions take priority over PMP or PMA exceptions.
Consequently, if a memory access violates both SPMP and PMP/PMA rules, only the SPMP exception is reported.

SPMP checks are enforced on all memory accesses with effective privilege modes less privileged than M-mode.
SPMP can be configured to grant permissions to U-mode, which has none by default, and to revoke permissions from S-mode.


[[spmp-and-paging]]
=== SPMP and Paging
SPMP and paged virtual memory are mutually exclusive and cannot be enabled concurrently for two primary reasons:

. Enabling both introduces a redundant layer of permission checks for each memory access.
+
. Paged virtual memory, by itself, offers a sufficient level of protection.

The following table dictates which isolation mechanism is active based on the satp configuration, assuming the hardware implements both.


[cols="^1,^1", stripes=even, options="header"]
|===
|satp|Isolation mechanism
|satp.mode == Bare|SPMP only
|satp.mode != Bare|Paged Virtual Memory only
|===


=== Extension Dependencies

. The `Sscsrind` extension for indirect CSR access must be implemented.
+
. The `sstatus.SUM` (permit Supervisor User Memory access) bit must be *writable*, deviating from the Privileged Architecture (i.e., `Svbare`). In SPMP, this writability is essential because the bit alters how S-mode load and store operations access user memory.
+
. The `sstatus.MXR` (Make eXecutable Readable) bit must be *writable*, deviating from the Privileged Architecture (i.e., `Svbare`). This writability supports M-mode emulation handlers that require reading instructions with `MXR=1 and MPRV=1`.


[[spmp_csrs]]
=== S-level Physical Memory Protection CSRs

Each SPMP entry is composed of a 16-bit configuration field within an XLEN-bit configuration register and an associated XLEN-bit address register.
From S-mode, the SPMP registers are accessible only via the indirect access mechanism (see <<access_method>>).
In TOR mode, an entry also uses the address register of the preceding entry to define its range (see <<address_matching>>).
Implementations support up to 64 SPMP entries.


[NOTE]
====
An SPMP entry refers to the register pair `spmpcfg[i]` and `spmpaddr[i]`.

An SPMP rule is defined by the contents of an `spmpcfg` register and its corresponding `spmpaddr` register(s). 
These registers collectively define a protected physical memory region and its access constraints. 
For a rule to be valid, its `spmpcfg[i].A` field must not be OFF. 
Furthermore, if `spmpcfg[i].A` is set to TOR, the condition `spmpaddr[i-1] < spmpaddr[i]` must hold.
====

The SPMP address registers, named `spmpaddr0` through `spmpaddr63`, share the same layout as PMP architecture.
On RV32 systems, each `spmpaddr` register encodes a 34-bit physical address from bit 33 down to bit 2, as illustrated in <<spmpaddr-rv32>>.
On RV64 systems, each `spmpaddr` register encodes a 56-bit physical address from bit 55 down to bit 2, as shown in <<spmpaddr-rv64>>.
An implementation may support fewer address bits, particularly on systems with a smaller physical address space.
All writable SPMP entries should implement a consistent number of address bits.
Since not all physical address bits must be implemented, the SPMP address registers are considered WARL, with exceptions defined by granularity rules.
Refer to the {privspec}, Section 3.7: Physical Memory Protection, Address Matching.


[[spmpaddr-rv32]]
.SPMP address register format, RV32.
include::images/bytefield/spmpaddr-rv32.adoc[]

[[spmpaddr-rv64]]
.SPMP address register format, RV64.
include::images/bytefield/spmpaddr-rv64.adoc[]

Every SPMP entry contains a 16-bit configuration field, `spmpcfg[i]`.
Its lower 8 bits are an alias for the 8-bit field of the corresponding PMP configuration register.
<<spmpcfg>> illustrates the layout of `spmpcfg[i]`.
Permission rules and their encodings are detailed in <<encoding>>.

. The R, W, and X bits govern permissions for read, write, and instruction execution, respectively.
. The A field, which defines the address-matching mode, is detailed in <<address_matching>>.
. Bits 5 and 6 are reserved for future standard use.
. The L (lock) bit designates an entry as locked.
Setting the L bit locks the SPMP entry, regardless of the A field's setting (even OFF).
Modifications to locked `spmpcfg[i]` and `spmpaddr[i]` registers are only permitted through execution environment access via `miselect`.
Attempts to write to locked `spmpcfg[i]` and `spmpaddr[i]` registers using the `siselect` CSR are ignored, irrespective of privilege level.
If a locked entry has `spmpcfg[i].A` set to TOR, writes to the preceding `spmpaddr[i-1]` via `siselect` are also ignored.
. If locking is not a required feature, an implementation can hardwire the L bit to 0.
. For any rule not designated as a `Shared-Region`, the U bit determines if it is `U-mode` (when set) or `S-mode-only` (when clear), as explained in <<encoding>>.
. The SHARED bit identifies a rule as a `Shared-Region` rule.


[[spmpcfg]]
.SPMP configuration register format.
include::images/bytefield/spmpcfg.adoc[]


[NOTE]
====
M-mode can leverage the L bit to create a sandbox for S-mode software. 
This is achieved by setting and locking high-priority SPMP entries where `spmpcfg[i].U` is 1. 
This mechanism effectively thwarts privilege escalation attacks that might try to reconfigure SPMP entries to bypass S-mode restrictions. 
While PMP/ePMP entries could offer a similar function, the resulting configuration is not identical because PMP does not distinguish between S-mode and U-mode. 
Moreover, if resource sharing is statically defined (e.g., `mpmpdeleg.pmpnum` is hardwired, see <<PMP_Entry_Sharing>>), there might not be enough PMP/ePMP entries to enforce the intended isolation policy.
====



[[encoding]]
=== Encoding of Permissions


SPMP supports three distinct rule types: *S-mode-only*, *U-mode* and *Shared-Region*.

. An *S-mode-only* rule is *enforced* for accesses from Supervisor mode and *denied* for accesses from User mode.
+
. A *U-mode* rule is always enforced for User mode accesses. Its behavior for Supervisor mode accesses depends on the `sstatus.SUM` bit.
+
* With `sstatus.SUM` set, the rule is enforced for Supervisor mode data accesses, but execution permission is denied (termed *EnforceNoX* in <<spmpencode>>). This prevents the OS from executing the memory of an unprivileged process at all times.
+
* With `sstatus.SUM` clear, the rule is denied for any Supervisor mode access. This prevents the OS from accessing the memory of an unprivileged process unless a specific code path is followed.
+
. The encoding `spmpcfg.SHARED == 1 and spmpcfg.U == 1` defines a *Shared-Region* rule. For shared regions, the state of the `sstatus.SUM` bit is irrelevant.
+
. A *Shared-Region* rule is *enforced* for both Supervisor and User modes, but it imposes the constraint that read and write permissions for User mode are mutually exclusive. 
+
. The R, W, and X bits collectively form a WARL field.
+
. The encoding `spmpcfg.RWX=010`, `spmpcfg.RWX=011`, and the combination `spmpcfg.SHARED == 1 and spmpcfg.U == 0` are all reserved for future standard use.


The complete table of encodings and their outcomes is presented in <<spmpencode>>:

[[spmpencode]]
image::SPMP_Encoding_Table_v11.svg[title="SPMP Encoding Table"]

*Deny*: The memory access is blocked and an exception is raised.

*Enforce*: The R/W/X permissions defined in `spmpcfg` are applied to the access.

*EnforceNoX*: The R/W permissions from `spmpcfg` are applied, but execute permission is denied.

*Reserved*: This encoding is reserved for future standard use.

*SUM bit*: The SPMP mechanism uses the `sstatus.SUM` (permit Supervisor User Memory access) bit to alter the privilege of S-mode load and store operations on physical memory.
The semantics of `sstatus.SUM` within SPMP are consistent with its definition in the Machine-Level ISA (for details, refer to the "Memory Privilege in mstatus Register" subsection of the {privspec}).


[[address_matching]]
=== Address Matching

The A field within an SPMP entry's configuration register determines the address-matching mode for its associated spmpaddr register.
The following table details the A field's encoding.

[cols="^1,^1,^3", stripes=even, options="header"]
|===
|spmpcfg[i].A|Name|Description
|0|OFF|Null region (disabled)
|1|TOR|Top of range
|2|NA4|Naturally aligned four-byte region
|3|NAPOT|Naturally aligned power-of-two region, ≥8 bytes
|===

This encoding is consistent with the PMP/ePMP.
For comprehensive details, refer to the "Address Matching" subsection for PMP in the {privspec}.


[NOTE]
====
Software can probe the minimum SPMP granularity.
This is done by clearing `spmpcfg[i]`, writing all ones to `spmpaddr[i]`, and then reading back the resulting `spmpaddr[i]` value.
If asciimath:[G] is the index of the least-significant bit set in the result, the granularity is asciimath:[2^{G+2}] bytes.

Software can also determine the implemented physical address size.
This involves setting `spmpcfg[i].A` to `0b11`, writing all ones to `spmpaddr[i]`, and reading back the result.
(Consult the "NAPOT range encoding in PMP address and configuration registers" table in the {privspec} for interpretation.)

Because the `spmpcfg[i].A` field is WARL, an implementation is free to hardwire a specific address-matching mode.
====


=== Matching Logic


. SPMP entries are statically prioritized.
+
. The lowest-numbered SPMP entry that matches any byte of an access (indicated by an address and the accessed length) determines whether that access is allowed or denied.
+
. This matching SPMP entry must match *all* bytes of the access, or the access fails and an instruction, load, or store page-fault exception is generated (see <<exceptions>>).
+
. This matching is done irrespective of the SHARED, U, R, W, and X bits.
+
. If the effective privilege mode of the access is M, the access is `allowed`.
+
. If the effective privilege mode of the access is S/U and no SPMP entry matches, but at least one SPMP entry is implemented, the access is `denied`.
+
. Otherwise, each access is checked according to the permission bits in the matching SPMP entry. That access is allowed if it satisfies the permission checking with the encoding corresponding to the access type.


Certain implementations may decompose misaligned memory operations into multiple accesses.
In such cases, some of these sub-accesses might succeed before another triggers an exception.
Notably, a portion of a misaligned store that passes an SPMP check could become architecturally visible, even if another portion of the same store fails.
This behavior may also occur for stores wider than XLEN (e.g., FSD instruction in RV32D), even if the store address is naturally aligned.

SPMP rules are checked for all memory accesses, both implicit and explicit, that originate from S-mode or any less-privileged mode. 


[NOTE]
====
The execution environment is expected to configure one or more SPMP entries to grant S-mode its necessary baseline permissions. 
S-mode software can subsequently constrain these permissions by refining the SPMP entries.
====


[[access_method]]
=== The Access Method for SPMP CSRs in S-mode
Each value of `siselect` maps to a corresponding set of SPMP CSRs.
`sireg` is used to access the `spmpaddr` register, while `sireg2` is used for the `spmpcfg` register.
The registers `sireg3` through `sireg6` are read-only 0.

SPMP entries are indexed starting from zero.
In a system with 48 SPMP entries, S-mode can address `SPMP[0..47]` using `siselect#0..47`.
An access to an out-of-bounds index via `siselect` will return zero on read and be ignored on write.


<<<
[cols="^1,^2",stripes=even, options="header"]
|===
|`siselect` value| indirect CSR access of `sireg`
|`0x100`|`sireg` -> `spmpaddr[0]`, `sireg2` -> `spmpcfg[0]`
|`0x101`|`sireg` -> `spmpaddr[1]`, `sireg2` -> `spmpcfg[1]`
|    ...     |    ...
|`0x13F`|`sireg` -> `spmpaddr[63]`, `sireg2` -> `spmpcfg[63]`
|===

[NOTE]
====
The rationale for disallowing `siselect` writes to clear a lock bit is to isolate this capability within the `miselect` CSR space, rather than merely differentiating by privilege mode. 

The design choice to map only one SPMP entry per `siselect` value is motivated by performance. 
Mapping multiple entries would necessitate a jump table or extra logic to select the correct target `sireg` register, adding overhead. 

When `spmpcfg1` is written via `siselect` and `sireg2`, the full 16-bit value is written right-justified, even though the hardware may store the upper and lower 8 bits in separate register arrays. 

For further details on indirect CSR access, refer to the `Sscsrind` extension specification in the {privspec}.
====


[[exceptions]]
=== Exceptions
A failed SPMP check triggers an exception whose type corresponds to the memory operation (load, store/AMO, or instruction fetch).
Each fault type is assigned a distinct exception code.

The `Sspmp` extension co-opts the existing page fault exception codes for SPMP violations, as page fault handling is typically already delegated to S-mode.
S-mode software (e.g., an OS) can differentiate between an SPMP fault and a standard page fault by querying the `satp.mode` field, given that SPMP and paging are mutually exclusive (see <<spmp-and-paging>>).

It is important to note that a single instruction can result in multiple memory accesses that are not guaranteed to be atomic relative to each other.


Table of exception codes:

[cols="^1,^1,^1", stripes=even, options="header"]
|===
|Interrupt|Exception Code|Description
|0|12|Instruction page fault
|0|13|Load page fault
|0|15|Store/AMO page fault
|===

